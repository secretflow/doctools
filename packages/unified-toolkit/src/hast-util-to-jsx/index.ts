import type * as hast from 'hast';
import type * as mdast from 'mdast';
import type * as mdx from 'mdast-util-mdx';
import postcss from 'postcss';
import * as postcssJs from 'postcss-js';
import * as propertyInfo from 'property-information';
import type { Node } from 'unist';
import { filter } from 'unist-util-filter';
import { map } from 'unist-util-map';

// adapted from https://github.com/mapbox/jsxtreme-markdown/blob/a4475c4974f0a8ee04b30a750edb538d262d0fbb/packages/hast-util-to-jsx/index.js#L85
function htmlPropertyToJSXAttribute(
  name: string,
  value: hast.Properties[string],
): mdx.MdxJsxAttribute | null {
  if (value === undefined || (typeof value === 'number' && isNaN(value))) {
    return null;
  }

  const info = propertyInfo.find(propertyInfo.html, name);

  let propName = info.property;

  if (info.attribute.startsWith('aria-') || info.attribute.startsWith('data-')) {
    propName = info.attribute;
  }
  if (propName in propertyInfo.hastToReact) {
    propName = propertyInfo.hastToReact[propName];
  }

  let propValue: typeof value | object = value;

  if (propName === 'style') {
    try {
      const parsed = postcss.parse(String(value));
      propValue = postcssJs.objectify(parsed);
    } catch (e) {
      propValue = {};
    }
  }

  if (info.number) {
    const coerced = Number(propValue);
    if (!isNaN(coerced)) {
      propValue = coerced;
    }
  }
  if (info.boolean) {
    propValue = true;
  }
  if (info.booleanish) {
    propValue = propValue === 'true' || propValue === true;
  }

  if (Array.isArray(propValue)) {
    if (info.commaSeparated) {
      propValue = propValue.join(', ');
    } else if (info.spaceSeparated) {
      propValue = propValue.join(' ');
    } else {
      propValue = String(propValue);
    }
  }

  if (typeof propValue === 'string') {
    return {
      type: 'mdxJsxAttribute',
      name: propName,
      value: propValue,
    };
  } else {
    const stringified = JSON.stringify(propValue);
    return {
      type: 'mdxJsxAttribute',
      name: propName,
      value: {
        type: 'mdxJsxAttributeValueExpression',
        value: stringified,
      },
    };
  }
}

function hastElementToJSX(
  node: hast.Element,
): mdx.MdxJsxFlowElement | mdx.MdxJsxTextElement {
  const startLine = node.position?.start.line ?? 0;
  const endLine = node.position?.end.line ?? 1;
  const type = startLine === endLine ? 'mdxJsxTextElement' : 'mdxJsxFlowElement';

  const attributes: mdx.MdxJsxAttribute[] = [];
  Object.entries(node.properties ?? {}).forEach(([name, value]) => {
    const prop = htmlPropertyToJSXAttribute(name, value);
    if (prop !== null) {
      attributes.push(prop);
    }
  });

  return {
    type,
    name: node.tagName,
    attributes,
    children: [],
  };
}

export function toJSX(tree: Node): Node {
  const mapped = map(tree, (hastNode): mdast.Content | mdast.Root => {
    const node = hastNode as hast.Content | hast.Root;
    switch (node.type) {
      case 'element':
        return hastElementToJSX(node);
      case 'text':
        if (/^\s*$/.test(node.value)) {
          return { type: 'mdxTextExpression', value: `/* */` };
        }
        return { type: 'mdxTextExpression', value: JSON.stringify(node.value) };
      case 'mdxJsxFlowElement':
      case 'mdxJsxTextElement':
      case 'root':
        return { ...node, children: [] };
      case 'mdxjsEsm':
      case 'mdxTextExpression':
      case 'mdxFlowExpression':
        return node;
      case 'comment':
      case 'doctype':
      default:
        return { type: 'mdxTextExpression', value: `/* */` };
    }
  });

  const filtered = filter(mapped, (node) => {
    if (
      node.type === 'mdxTextExpression' &&
      (<mdx.MdxTextExpression>node).value === '/* */'
    ) {
      // filter out all comments generated by empty nodes
      return false;
    }
    if (
      (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') &&
      (<mdx.MdxJsxFlowElement>node).name === 'script'
    ) {
      // filter out all script tags to prevent XSS
      return false;
    }
    return true;
  });

  if (filtered === null) {
    const empty: mdast.Root = { type: 'root', children: [] };
    return empty;
  }

  return filtered;
}
