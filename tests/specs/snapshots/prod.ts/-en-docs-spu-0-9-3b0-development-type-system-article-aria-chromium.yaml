- article:
  - heading "Type System" [level=1]:
    - link "Direct link to Type System":
      - /url: "#type-system"
  - heading "Overview" [level=2]:
    - link "Direct link to Overview":
      - /url: "#overview"
  - paragraph: This document is for VM developers.
  - paragraph: Everything in SPU could be treated as an object, each object has a type.
  - paragraph:
    - text: There are only two types of objects,
    - emphasis: value
    - text: or
    - emphasis: operator
    - text: ", which means if a symbol is not a"
    - emphasis: value
    - text: ", it’s an"
    - emphasis: operator
    - text: .
  - list:
    - listitem:
      - strong: value
      - text: ": an object that is managed by SPU runtime, representing a public/secret data."
    - listitem:
      - strong: operator
      - text: ": an object that takes one or more values and outputs a return value, i.e. multiply is an operator."
  - heading "Value type" [level=3]:
    - link "Direct link to Value type":
      - /url: "#value-type"
  - paragraph:
    - text: A value type is a tuple (
    - strong: V
    - text: ","
    - strong: D
    - text: ","
    - strong: S
    - text: "), where:"
  - list:
    - listitem:
      - strong: V
      - text: is
      - emphasis: visibility
      - text: ", could be one of"
      - emphasis: "{public, secret}"
    - listitem:
      - strong: D
      - text: is
      - emphasis: data type
      - text: ", could be one of"
      - emphasis: "{int, fxp}"
    - listitem:
      - strong: S
      - text: is
      - emphasis: shape
      - text: ", which makes the value a tensor."
  - paragraph: We can define a hyper type function, which takes three parameters and return a concrete value type.
  - button "Copy":
    - img "copy"
  - code: type(V, D, S) -> ValueType
  - paragraph:
    - text: To simplify things a little bit, we can ignore
    - emphasis: shape
    - text: for now and assume that runtime will handle it correctly.
  - button "Copy":
    - img "copy"
  - code: type(V, D) -> ValueType
  - paragraph: With this type function, we can define a list of types in the SPU type system.
  - button "Copy":
    - img "copy"
  - code: haskell
  - code: sint = type(secret, int) sfxp = type(secret, fxp) pint = type(public, int) pfxp = type(public, fxp)
  - heading "Operator type" [level=3]:
    - link "Direct link to Operator type":
      - /url: "#operator-type"
  - paragraph:
    - emphasis: Operators
    - text: takes a list of values as parameters and returns exactly one value as result, operator’s type is determined by the types of input parameters and return values.
  - paragraph: "In SPU IR, an operator could take a polymorphic typed parameter and the return type could be deduced from the parameters. For example:"
  - button "Copy":
    - img "copy"
  - code: haskell
  - code: add (sint, pint) -> sint add (sint, sint) -> sint add (pint, pint) -> pint ... add (sfxp, pint) -> sfxp ...
  - paragraph:
    - text: /The add operator takes a pair of type\(V, D\) as parameter, which has 2x2x2x2 = \d+ different kinds of combinations\. To support this type of operators, we introduce the following/
    - emphasis: type functor
    - text: .
  - list:
    - listitem:
      - strong: dtype promotion
      - text: ", which promotes two dtypes to a more relaxed type, in SPU system,"
      - emphasis: int
      - text: is always promoted to
      - emphasis: fxp
      - text: .
  - button "Copy":
    - img "copy"
  - code: haskell
  - code: "promote :: list[D] -> D -- for example add (int, fxp) -> fxp"
  - list:
    - listitem:
      - strong: visibility narrow
      - text: ", which narrows the visibility when two or more operands have different visibility properties, this is the key to maintain the “secure semantic” of SPU VM, since the resulting visibility of ops will always be more strict. i.e. if one of operands is"
      - emphasis: secret
      - text: ", the result is a"
      - emphasis: secret
      - text: .
  - button "Copy":
    - img "copy"
  - code: haskell
  - code: "narrow :: list[V] -> V -- for example add (secret, public) -> secret add (public, public) -> public"
  - paragraph: "Now we can represent the polymorphic mul op as:"
  - button "Copy":
    - img "copy"
  - code: "mul :: type(V0, D0) -> type(V1, D1) -> type(narrow(V0, V1), promote(D0, D1))"
  - list:
    - listitem:
      - text: the op takes two parameters, first type is
      - code: type(V0, D0)
      - text: ", second type is"
      - code: type(V1, D1)
      - text: .
    - listitem:
      - text: the op returns
      - code: type(narrow(V0, V1), promote(D0, D1))
      - text: as a result.
    - listitem: when applying the op to two arbitrary arguments, the result could be deduced from the above type expressions.
  - heading "Use of type" [level=3]:
    - link "Direct link to Use of type":
      - /url: "#use-of-type"
  - paragraph: There are many uses for types.
  - list:
    - listitem:
      - text: First, the most important one, type is self descriptive, with an accurate defined type system, we can describe
      - emphasis: SPU IR
      - text: more accurately.
    - listitem: Second, runtime type information is used to do runtime dispatch, which is important for polymorphic operators.
    - listitem: Third, the type system could be used by static type checker, and could be used to double check runtime implementation.
  - heading "Ops dispatch" [level=2]:
    - link "Direct link to Ops dispatch":
      - /url: "#ops-dispatch"
  - paragraph: As described above, type helps for dispatching, here we use MUL instruction as an example.
  - button "Copy":
    - img "copy"
  - code: "%3 = MUL %1 %2"
  - paragraph: The above MUL instruction does element-wise multiplication, %1 and %2 are parameters and %3 is the return value.
  - heading "The dispatch problem" [level=3]:
    - link "Direct link to The dispatch problem":
      - /url: "#the-dispatch-problem"
  - paragraph: "In this example, %1 and %2 are SPU values, each of them belongs one of four types {sint, pint, sfxp, pfxp}, the type of MUL is:"
  - math: "{ s i n t p i n t s f x p p f x p } × { s i n t p i n t s f x p p f x p }"
  - paragraph:
    - strong: The problem is how to dispatch operations to correct kernel according to the arguments’ type information
    - text: .
  - paragraph: /A simple idea is to pattern match all these type combinations and dispatch to different kernels accordingly, with this way we got 4x4=\d+ different kernels\./
  - document: mul dispatch mul mul mul mul mul ... mul
  - heading "Layered dispatch" [level=3]:
    - link "Direct link to Layered dispatch":
      - /url: "#layered-dispatch"
  - paragraph: A better way is to dispatch layer by layer, for example, first dispatch by dtype, then dispatch by vtype.
  - document: mul dtype dispatch imul rmul fmul + vtype dispatch mulss mulsp mulpp rtrunc vtype dispatch truncss truncsp truncpp
  - paragraph: "In the above diagram:"
  - list:
    - listitem:
      - strong: mul
      - text: is general
      - emphasis: multiplication
      - text: method.
    - listitem:
      - strong: imul
      - text: is integer multiplication method.
    - listitem:
      - strong: fmul
      - text: is fixedpoint multiplication method.
    - listitem:
      - strong: rmul
      - text: /is untyped multiplication method over ring [\d,.]+[bkmBKM]+\./
    - listitem:
      - strong: mulss
      - text: multiplies two secrets, the domain and behavior are secure protocol dependent.
  - paragraph: "The above idea can be expressed in code like:"
  - button "Copy":
    - img "copy"
  - code: cpp
  - code: "Value i2f(Value); // convert int to fxp Value mul(Value x, Value y) { Type xt = x.type(); Type yt = y.type(); // first level, dispatch by dtype. if (is_int(xt) && is_int(yt)) return imul(x, y); if (is_int(xt) && is_fxp(yt)) return fmul(i2f(x), y); if (is_fxp(xt) && is_int(yt)) return fmul(x, i2f(y)); if (is_fxp(xt) && is_fxp(yt)) return fmul(x, y); } Value imul(Value x, Value y) { Type xt = x.type(); Type yt = y.type(); // second level, dispatch by vtype. if (is_secret(xt) && is_secret(yt)) return _mul_ss(x, y); if (is_secret(xt) && is_public(yt)) return _mul_sp(x, y); if (is_public(xt) && is_secret(yt)) return _mul_sp(y, x); // commutative if (is_public(xt) && is_public(yt)) return _mul_pp(x, y); } Value fmul(Value x, Value y) { Value z = imul(x, y); return truncate(z); }"
  - heading "Fast dispatch" [level=3]:
    - link "Direct link to Fast dispatch":
      - /url: "#fast-dispatch"
  - paragraph: In the above example, we observe that i2f and truncation could be optimized, the intuition is that when a value is converted from int to fxp and later convert back, these two conversion introduce non-trivial computation overhead in MPC setting.
  - paragraph:
    - text: We use the so called
    - emphasis: fast dispatch
    - text: to optimize it, when doing cross int and fxp multiplication, we could directly do imul without type lift and truncation.
  - button "Copy":
    - img "copy"
  - code: cpp
  - code: "Value i2f(Value); // convert int to fxp Value mul(Value x, Value y) { Type xt = x.type(); Type yt = y.type(); // fast dispatch if (one_int_another_fxp(xt, yt)) return imul(x, y); if (is_int(xt) && is_int(yt)) return imul(x, y); if (is_int(xt) && is_fxp(yt)) return fmul(i2f(x), y); // lift to f, then truncation back. if (is_fxp(xt) && is_int(yt)) return fmul(x, i2f(y)); // lift to f, then truncation back. if (is_fxp(xt) && is_fxp(yt)) return fmul(x, y); }"
  - paragraph: "Note:"
  - list:
    - listitem: in the above implementation we didn’t maintain the type correctness.
    - listitem:
      - text: this pattern match based
      - emphasis: fast dispatch
      - text: is exactly the same as compile-time
      - emphasis: peephole optimization
      - text: .
    - listitem: dispatch inside a protocol is also complicated and beyond the scope of this article.
  - heading "Implementation" [level=3]:
    - link "Direct link to Implementation":
      - /url: "#implementation"
  - paragraph:
    - text: With
    - emphasis: type functor
    - text: ", we have the following op definitions in mul dispatch chain."
  - button "Copy":
    - img "copy"
  - code: haskell
  - code: "mul :: type(#V0,$D0) -> type(#V1,$D1) -> type(narrow(#V0, #V1), promote($D0, $D1)) fmul :: type(#V0,FXP) -> type(#V1,FXP) -> type(narrow(#V0, #V1), FXP) rmul :: type(#V0,$$) -> type(#V1,$$) -> type(narrow(#V0, #V1), $$) mulss :: type(SECRET,$$) -> type(SECRET,$$) -> type(SECRET,$$)"
  - paragraph: "In dispatch phrase, SPU runtime uses type information to select next dispatch op. In this example, (x:sfxp, y:sfxp) is applied op mul, via pattern matching we got (V0=SECRET,D0=FXP), (V1=SECRET,D1=FXP), and the dispatch stack looks like:"
  - button "Copy":
    - img "copy"
  - code: plaintext
  - code: "mul(x:sfxp, y:sfxp) # dtype dispatch, use D0=FXP, D1=FXP to select fmul fmul(x:sfxp, y:sfxp) # fixed point arithmetic implementation, # first do ring multiplication, then truncate the result. z = rmul(x:s<T>, y:s<T>) # rmul does ring arithmetic over protocol dependent # encoding, and use (V0=SECRET,V1=SECRET) to select mulss mulss(x:U, y:U) # mulss dispatch to concrete protocol implementation, # in protocol defined field. rtruncate(z:s<T>) # rtrunc does ring truncation over protocol dependent # field, and use (V0=SECERT) to select truncates truncs(z:U) # dispatch to concrete protocol implementation."
  - paragraph: "Note:"
  - list:
    - listitem: We use C++-like template type notation to represent polymorphic type constraints.
  - heading "Partial type" [level=4]:
    - link "Direct link to Partial type":
      - /url: "#partial-type"
  - paragraph:
    - text: In the type dispatch step, type information is used to select next op, and when partial of type information is used, it’s
    - emphasis: erased
    - text: . For example, when dtype is used to select fmul in the above example, dtype is useless in the future and could be erased, the lower level op does not distinguish dtype (via a generic type parameter). In a real implementation, we don’t erase the type explicitly, just leave it there without further use.
  - paragraph:
    - text: The return value takes the reverse progress of dispatch. The return type is filled from bottom to up. For example, in the above progress, when
    - code: z=rmul(x,y)
    - text: is called, rmul knows z’s visibility type is SECRET but does not know its dtype yet, so here z has a partial type type(SECRET, $UNKNOWN). The type will be filled step by step during stack popup, and eventually be completed as a full type when the whole dispatch progress is done.