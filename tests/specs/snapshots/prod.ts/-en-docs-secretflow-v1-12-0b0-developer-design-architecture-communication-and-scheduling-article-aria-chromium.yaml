- article:
  - heading "Architecture" [level=1]:
    - link "Direct link to Architecture":
      - /url: "#architecture"
  - paragraph: SecretFlow is a unified framework for privacy preserving data analysis and machine learning.
  - paragraph:
    - img
  - heading "Design Motivation" [level=2]:
    - link "Direct link to Design Motivation":
      - /url: "#design-motivation"
  - paragraph: privacy-preserving computing is an emerging interdisciplinary field involving cryptography, machine learning, databases, hardware, and other fields. Based on the practical experience over the past few years, we found that
  - list:
    - listitem: No privacy-preserving computing technology is suitable for all scenarios.
    - listitem: Private computing has a high learning curve and is difficult for users from other backgrounds to use.
    - listitem: Privacy-preserving computing involves many fields and requires the cooperation of different domain experts.
  - paragraph: The design goal of SecretFlow is to make it very easy for data scientists and machine learning developers to use private computing techniques for data analysis and machine learning without knowing the underlying technical details. To achieve this goal, SecretFlow provides a layer of device abstraction that abstracts Multi-Party Secure Computing (MPC), Homomorphic Encryption (HE), and Trusted Execution Environment (TEE) into ciphertext devices. Based on this level of abstraction, data analysis and machine learning workflows can be represented as a computational graph, where nodes represent computations on a device and edges represent the data flow between devices. Data flow between different types of devices requires protocol conversion. In this regard, SecretFlow borrows from mainstream deep learning frameworks, which represent neural networks as a computational graph consisting of on-device operators and tensor flows between devices.
  - paragraph: SecretFlow is an open framework for developers at different levels. At the device layer, we work with experts in cryptography, trusted hardware, hardware acceleration and other fields to continuously improve protocol security and computing performance. At the same time, SecretFlow provides a good device interface, and the third-party privacy-preserving computing protocol can be plugged in as a device. At the algorithm layer, a flexible programming interface is provided for machine learning, and algorithm developers can easily define their own algorithms.
  - heading "Device" [level=2]:
    - link "Direct link to Device":
      - /url: "#device"
  - paragraph: "The devices of the SecretFlow are divided into physical devices and logical devices. The physical device is the physical machine of each participant in the privacy-preserving computing, and the logical device is composed of one or more physical devices. A logical device supports a specific set of computing operators (Device Ops) and has its own specific data representation (Device Object). Logical devices are divided into two types: plaintext and ciphertext. The former performs unilateral local computation, while the latter performs multi-party private computation."
  - paragraph: The runtime of a logical device is responsible for memory management, data transmission, operator scheduling and other responsibilities, and runs on one or more physical devices. There is no one-to-one relationship between logical devices and physical devices, and a physical device may belong to multiple logical devices at the same time. On the same set of physical devices, different logical devices can be virtualized according to different privacy protocols and participation combinations.
  - paragraph:
    - img
  - paragraph: "The following table is a list of devices currently supported by SecretFlow:"
  - table:
    - rowgroup:
      - row "Device Type Runtime Ops Protocol Frontend Status":
        - cell "Device":
          - paragraph: Device
        - cell "Type":
          - paragraph: Type
        - cell "Runtime":
          - paragraph: Runtime
        - cell "Ops":
          - paragraph: Ops
        - cell "Protocol":
          - paragraph: Protocol
        - cell "Frontend":
          - paragraph: Frontend
        - cell "Status":
          - paragraph: Status
    - rowgroup:
      - row "PYU Plaintext Python Interpreter — — Python Release":
        - cell "PYU":
          - paragraph: PYU
        - cell "Plaintext":
          - paragraph: Plaintext
        - cell "Python Interpreter":
          - paragraph: Python Interpreter
        - cell "—":
          - paragraph: —
        - cell "—":
          - paragraph: —
        - cell "Python":
          - paragraph: Python
        - cell "Release":
          - paragraph: Release
      - row /SPU Ciphertext SPU VM PSI, XLA HLO SPDZ-[\d,.]+[bkmBKM]+, ABY3 JAX, TensorFlow, PyTorch Alpha/:
        - cell "SPU":
          - paragraph: SPU
        - cell "Ciphertext":
          - paragraph: Ciphertext
        - cell "SPU VM":
          - paragraph: SPU VM
        - cell "PSI, XLA HLO":
          - paragraph: PSI, XLA HLO
        - cell /SPDZ-[\d,.]+[bkmBKM]+, ABY3/:
          - paragraph: /SPDZ-[\d,.]+[bkmBKM]+, ABY3/
        - cell "JAX, TensorFlow, PyTorch":
          - paragraph: JAX, TensorFlow, PyTorch
        - cell "Alpha":
          - paragraph: Alpha
      - row "HEU(PHEU Mode) Ciphertext PHEU Runtime Add Paillier Numpy Alpha":
        - cell "HEU(PHEU Mode)":
          - paragraph: HEU(PHEU Mode)
        - cell "Ciphertext":
          - paragraph: Ciphertext
        - cell "PHEU Runtime":
          - paragraph: PHEU Runtime
        - cell "Add":
          - paragraph: Add
        - cell "Paillier":
          - paragraph: Paillier
        - cell "Numpy":
          - paragraph: Numpy
        - cell "Alpha":
          - paragraph: Alpha
      - row "HEU(FHEU Mode) Ciphertext HEU VM XLA HLO TFHE JAX, TensorFlow, PyTorch WIP":
        - cell "HEU(FHEU Mode)":
          - paragraph: HEU(FHEU Mode)
        - cell "Ciphertext":
          - paragraph: Ciphertext
        - cell "HEU VM":
          - paragraph: HEU VM
        - cell "XLA HLO":
          - paragraph: XLA HLO
        - cell "TFHE":
          - paragraph: TFHE
        - cell "JAX, TensorFlow, PyTorch":
          - paragraph: JAX, TensorFlow, PyTorch
        - cell "WIP":
          - paragraph: WIP
      - row "TEE Ciphertext TEE Runtime XLA HLO Intel SGX JAX, TensorFlow, PyTorch WIP":
        - cell "TEE":
          - paragraph: TEE
        - cell "Ciphertext":
          - paragraph: Ciphertext
        - cell "TEE Runtime":
          - paragraph: TEE Runtime
        - cell "XLA HLO":
          - paragraph: XLA HLO
        - cell "Intel SGX":
          - paragraph: Intel SGX
        - cell "JAX, TensorFlow, PyTorch":
          - paragraph: JAX, TensorFlow, PyTorch
        - cell "WIP":
          - paragraph: WIP
  - heading "Programmability" [level=3]:
    - link "Direct link to Programmability":
      - /url: "#programmability"
  - paragraph: Logic devices are programmable which users can customize computing logic, and each device provides a protocol-independent programming interface to the user. On one device, users can define anything from simple matrix operations, to full deep model training, and even arbitrary execution logic, depending on the computing ability provided by the device.
  - paragraph:
    - text: For the plaintext device PYU, its front-end is python, and users can schedule any python function to execute on it through
    - code: "@device"
    - text: . These functions are serialized, transported, deserialized by
    - code: cloudpickle
    - text: and executed by the target device’s python interpreter.
  - paragraph:
    - text: For ciphertext devices SPU, HEU, TEE, their front end can be any framework that supports
    - link "XLA":
      - /url: https://www.tensorflow.org/xla/architecture
    - text: ", such as JAX, TensorFlow, PyTorch. Similarly, users can also dispatch functions based on these front-end to a specified device for execution through"
    - code: "@device"
    - text: .
  - blockquote:
    - paragraph: Currently, we recommend that you use JAX as the front end. And before using JAX, we strongly recommend that you must read the following documents.
    - list:
      - listitem:
        - link "https://jax.readthedocs.io/en/latest/notebooks/quickstart.html":
          - /url: https://jax.readthedocs.io/en/latest/notebooks/quickstart.html
      - listitem:
        - link "https://jax.readthedocs.io/en/latest/notebooks/thinking_in_jax.html":
          - /url: https://jax.readthedocs.io/en/latest/notebooks/thinking_in_jax.html
      - listitem:
        - link "https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html":
          - /url: https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html
        - text: (
        - strong: IMPORTANT
        - text: )
  - button "Copy":
    - img "copy"
  - code: python
  - code: "/import jax\\.numpy as jnp dev = Device\\(\\) # maybe PYU, SPU, HEU, TEE @device\\(dev\\) def selu\\(x, alpha=\\d+\\.\\d+, lmbda=\\d+\\.\\d+\\): return lmbda \\* jnp\\.where\\(x > 0, x, alpha \\* jnp\\.exp\\(x\\) - alpha\\) res = selu\\(x\\) # res is a DeviceObject/"
  - paragraph: The user-defined function is first converted into XLA HLO Computation, and XLA performs device-independent code optimization and analysis, and sends it to the back-end device. The back-end device further performs code optimization and analysis, and generates the final executable code. Executable code or interpreted by the device’s virtual machine (SPU, HEU) , or directly executed by hardware (TEE). Using XLA HLO as IR allows us to reuse XLA front-end and device-independent code optimizations, while making the back-end implementation more concise and clean.
  - paragraph:
    - text: For the ciphertext device HEU, it only supports a limited set of calculations, so a set of predefined operators such as
    - code: __add__
    - text: ","
    - code: __mul__
    - text: ", etc. are provided, and users cannot customize programming through"
    - code: "@device"
    - text: .
  - button "Copy":
    - img "copy"
  - code: python
  - code: "x, y = HEUObject(), PYUObject() z = x + y # add z = x * y # mul z = x @ y # matmul"
  - paragraph: For more details on logical devices, please refer to the design documentation for each device.
  - heading "Protocol Conversion" [level=3]:
    - link "Direct link to Protocol Conversion":
      - /url: "#protocol-conversion"
  - paragraph:
    - text: The user performs programming on the logical device and constructs a logical computation graph, where the nodes represent a segment of functions or operators on the device, and the edges represent the flow of device objects. The logical computation graph is further divided into subgraphs by the device, and the edge between the two subgraphs represents the flow of objects across the device. At this time, protocol conversion is required.
    - code: DeviceObject.to
    - text: is used to convert to the target device object. Any new device should provide the corresponding conversion function and insert it into the object conversion table.
  - paragraph: "The following table is the translation table for each logical device object:"
  - table:
    - rowgroup:
      - row "PYU SPU HEU TEE":
        - cell
        - cell "PYU":
          - paragraph: PYU
        - cell "SPU":
          - paragraph: SPU
        - cell "HEU":
          - paragraph: HEU
        - cell "TEE":
          - paragraph: TEE
    - rowgroup:
      - row "PYU share encrypt encrypt":
        - cell "PYU":
          - paragraph: PYU
        - cell
        - cell "share":
          - paragraph: share
        - cell "encrypt":
          - paragraph: encrypt
        - cell "encrypt":
          - paragraph: encrypt
      - row "SPU reconstruct encrypt+add reconstruct+encrypt":
        - cell "SPU":
          - paragraph: SPU
        - cell "reconstruct":
          - paragraph: reconstruct
        - cell
        - cell "encrypt+add":
          - paragraph: encrypt+add
        - cell "reconstruct+encrypt":
          - paragraph: reconstruct+encrypt
      - row "HEU decrypt minus+decrypt decrypt+encrypt":
        - cell "HEU":
          - paragraph: HEU
        - cell "decrypt":
          - paragraph: decrypt
        - cell "minus+decrypt":
          - paragraph: minus+decrypt
        - cell
        - cell "decrypt+encrypt":
          - paragraph: decrypt+encrypt
      - row "TEE decrypt decrypt+share decrypt+encrypt":
        - cell "TEE":
          - paragraph: TEE
        - cell "decrypt":
          - paragraph: decrypt
        - cell "decrypt+share":
          - paragraph: decrypt+share
        - cell "decrypt+encrypt":
          - paragraph: decrypt+encrypt
        - cell
  - heading "Communication and Scheduling" [level=2]:
    - link "Direct link to Communication and Scheduling":
      - /url: "#communication-and-scheduling"
  - paragraph: The user builds a logical calculation graph based on the device, so how do we execute this calculation graph? Since logical devices are mapped to one or more physical devices, we need to correctly schedule operators on logical devices to their corresponding physical devices, and handle the data transmission relationship between these physical devices. There is no doubt that we need a distributed graph execution engine to solve these problems.
  - paragraph: "So what kind of distributed graph execution engine do we need? Here’s what SecretFlow’s requirements:"
  - list:
    - listitem:
      - strong: Fine-grained heterogeneous computing
      - text: ": In a logical computing graph, there are computing tasks with different granularities, ranging from simple data processing (second level) to complex multi-party training (several hours to tens of hours). At the same time, physical nodes have different hardware environments, such as CPU, GPU, TEE, FPGA, etc."
    - listitem:
      - strong: Flexible computing model
      - text: ": In horizontal and vertical scenarios, for different workflows such as data processing and model training, it supports multiple parallel models, such as data parallelism, model parallelism, and hybrid parallelism."
    - listitem:
      - strong: Dynamic execution
      - text: ": In the federated learning scenario, the data size, bandwidth latency, and machine performance of different institutions may vary greatly, which results in the efficiency of the synchronous mode being limited by the slowest worker nodes. Therefore, we want to support asynchronous training mode, which requires the graph execution engine to have dynamic execution capabilities."
  - paragraph: We comprehensively evaluate several popular distributed frameworks in the industry
  - list:
    - listitem:
      - link "Dask":
        - /url: http://distributed.dask.org/en/stable/
    - listitem:
      - link "Ray":
        - /url: https://docs.ray.io/en/latest/
    - listitem:
      - link "TensorFlow Distributed":
        - /url: https://www.tensorflow.org/guide/distributed_training
    - listitem:
      - link "PyTorch Distributed":
        - /url: https://pytorch.org/tutorials/beginner/dist_overview.html
  - paragraph: In the end, we chose Ray as the distributed engine of SecretFlow, which satisfies the above requirements of SecretFlow very well. The distributed primitives provided by Ray enable task scheduling and data transfer on logical devices to be easily mapped to physical devices. The asynchronous scheduling and dynamic execution capabilities provided by Ray make the execution of computational graphs more flexible and efficient.
  - paragraph:
    - img
  - paragraph: Ray is a distributed system suitable for LAN environments. To apply it to privacy-preserving computing scenarios, a lot of security reinforcement and environment adaptation needs to be done. We are in-depth cooperation with Ant Group’s Ray team to create a secure and reliable Ray framework suitable for privacy-preserving computing.
  - paragraph: In terms of security reinforcement, we have reinforced the framework as a whole by means of identity authentication, code pre-installation, and code storage. In the future, we will also explore mechanisms such as sandbox isolation, access control, and static graphs to further strengthen Ray’s security level. In terms of environment adaptation, in order to adapt to the characteristics of cross-organization network communication, we have promoted the development of related functions such as GCS gRPC communication, domain name support, and weak network disconnection handling. At the same time, we are also exploring the use of Ray ecosystem, such as Mars, Ray Datasets, Ray Train, etc., in privacy-preserving computing scenarios.
  - heading "Privacy Preserving Algorithm" [level=2]:
    - link "Direct link to Privacy Preserving Algorithm":
      - /url: "#privacy-preserving-algorithm"
  - paragraph: The abstraction of logical devices provides great flexibility for algorithm developers. They can freely combine these devices like building blocks, and customize computations on the devices to build their own privacy-preserving computing algorithms.
  - paragraph: "Here are some algorithms built by our device programming model:"
  - list:
    - listitem: Logistic regression, deep learning training on SPU, HEU.
    - listitem:
      - text: Build
      - link "HESS-LR":
        - /url: https://dl.acm.org/doi/10.1145/3447548.3467210
      - text: ","
      - link "HESS-XGB":
        - /url: https://dl.acm.org/doi/10.1145/3459637.3482361
      - text: with a combination of SPU, HEU.
    - listitem: In horizontal federated learning, do local training in PYU, and do gradient and weight aggregation in SPU and TEE.
    - listitem: In vertical split learning, splitting a model into multiple PYUs, using differential privacy to protect forward hidden layers and reverse gradients
  - paragraph: For the details of these algorithms, please refer to our tutorials and implementations, and look forward to your developing more interesting algorithms based on SecretFlow!